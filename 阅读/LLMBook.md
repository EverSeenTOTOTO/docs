# 大语言模型[^link]

[^link]: https://llmbook-zh.github.io/

1. 大语言模型主要通过预测下一个词元的预训练任务进行学习，虽然并没有针对特定的下游任务进行优化，却能够建立远强于传统模型的通用任务求解能力。实际上，<Notation>基于大规模无标注文本的下一个词元预测任务本质上可以看作一个多任务学习过程</Notation>，因为针对不同词元的预测任务可能涉及到情感分类（“...这部电影真好看”）、数值计算（“3+4=7”）、知识推理（“中国陆地面积最大的省份是新疆”）等非常多样的训练任务。

> 语言模型将每个（自然语言处理）任务都视为基于世界文本子集的下一个词预测问题。因此，如果无监督语言建模经过训练后具有足够的能力复原全部世界文本，那么本质上它就能够解决各种任务。

2. 大语言模型经过超大规模数据的预训练后，能够编码大量的文本语义知识信息。然而，这个阶段的模型能力仍然是通过通用的下一个词预测任务建立的，主要目的是为了进行预训练文本数据的恢复。为了提升模型的任务求解能力，需要设计合适的指令微调以及提示策略进行激发或诱导。在指令微调方面，可以使用自然语言表达的任务描述以及期望的任务输出对于大语言模型进行指令微调，从而增强大语言模型的通用任务求解能力，提升模型在未见任务上的泛化能力。通常来说，<Notation>现有的研究认为指令微调无法向大模型注入新的知识，而是训练大模型学会利用自身所掌握的知识与信息进行任务的求解</Notation>。

> 不要被“微调”这个词汇所迷惑，预训练之后的大模型并不是一个完成品仅需要作些小优化。这个阶段的模型并不能理解任务，假如你告诉它写一封邮件，它大概率只会接着生成一些邮件相关的字句。微调才是让其具备任务求解能力的关键。

> 摘自后文：一般来说，指令微调很难教会大语言模型预训练阶段没有学习到的知识与能力，它主要起到了对于模型能力的激发作用，而不是知识注入作用。

3. OpenAI 前首席科学家 Ilya Sutskever 在公开采访中指出大规模预训练本质上是在做一个世界知识的压缩，从而能够学习到一个编码世界知识的参数模型，这个模型能够通过解压缩所需要的知识来解决真实世界的任务。

## 预训练

## 微调和对齐

### 监督微调（Supervised Fine-Tuning，SFT）

### 基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF）

## 解码部署

> 模型调用时经常看到的一些参数，原来都来自解码阶段～

### 两种解码策略

1. <Notation type="underline">贪心搜索</Notation>：在每个生成步骤中都选择概率最高的词元。对于输出高度依赖于输入内容的任务，贪心搜索通常能改得到不错的结果，但是在开放式生成任务（比如故事生成和对话系统）中，贪心搜索有时会因为过于关注局部最优，而生成不自然、重复的句子。

2. <Notation type="underline">概率采样</Notation>：根据模型建模的概率分布采样得到下一个词元，增加了生成文本的多样性和随机性。

#### 贪心搜索的改进

+ <Notation type="underline">束搜索（Beam Search）</Notation>：在解码过程中，保留前 $n$ 个具有最高概率的句子，并最终选取整体概率最高的生成回复。这里的 $n$ 被成为束大小（Beam Size）。当 $n=1$，束搜索就退化为贪心搜索。

+ <Notation type="underline">长度惩罚</Notation>：由于束搜索中需要比较不同长度候选句子的概率，往往需要引入长度惩罚（Length Penalty）（也成为长度归一化）技术。如果没有长度惩罚，传统的束搜索会倾向于生成较短的句子，因为每生成一个单词，都会乘以一个小于1的概率，使得句子的生成概率逐渐变小。因此，可以在生成概率的计算中引入长度惩罚，通过将句子概率除以其长度的指数幂$α$，对于句子概率进行归一化处理，从而鼓励模型生成更长的句子。

+ <Notation type="underline">重复惩罚</Notation>：为了缓解贪心搜索重复生成的问题，可以使用$n$-元惩罚来强制避免生成重复的连续$n$个次元。进一步，还有一些相对“温和”的惩罚机制来降低生成重复词元的概率：
  + <Notation type="underline">出现惩罚（Presence Penalty）</Notation>：在生成过程中将已生成词元的logits（生成大模型输出之前 softmax 概率化之前的中间值）减去惩罚项$α$来降低该词元之后生成的概率。
  + <Notation type="underline">频率惩罚（Frequency Penalty）</Notation>：记录每个次元生成的数目，然后减去出现次数乘以惩罚项$α$，因此如果一个词元生成得越多，惩罚也就越大。

#### 随机采样的改进策略

+ <Notation type="underline">温度采样</Notation>：调整 softmax 函数中的温度系数。降低温度系数会使得概率分布更加集中，从而增加了高概率词元的采样可能性，同时降低了低概率词元的采样可能；当温度系数设置为1 时，该公式退化为标准的随机采样方法；而当温度系数趋近于0 时，实际上等同于贪心搜索，即总是选择概率最高的词。此外，当温度系数趋近于无穷大时，温度采样会退化为均匀采样。

+ <Notation type="underline">Top-k采样</Notation>：直接剔除概率较低的词元，限制模型从概率最高的前$k$个词元中进行采样。

+ <Notation type="underline">Top-p采样（又称核采样，Nucleus Sampling）</Notation>：由于top-k采样策略并不考虑整体概率分布，因此固定的常数k可能无法适应不同的上下文语境。在较为确定的生成场景中，当k设置为大于1 的数值时，均有可能引入错误答案；而在需要多样性的场景中，k设置为较小的值则会限制模型的多样化生成。top-p方法的核心思想是从一个符合特定概率条件的最小词元集合中进行采样，要求其中包含的所有词元累积概率大于或等于预设阈值p。在具体的实现过程中，top-p采样首先会按照生成概率从高到低的解码策略顺序对词元进行排序，然后不断将词元添加到一个临时的集合中，直到集合的累积概率首次超过阈值p。

+ <Notation type="underline">对比解码（Contrastive Decoding）</Notation>：研究表明，由于大模型比小模型具有更强的生成能力，因而在预测下一个词元时，大语言模型相较于小模型更倾向于为重要词元分配更高的概率。基于这个想法，对比解码通过计算一个较大的语言模型和一个较小的语言模型之间的对数概率分布差值，然后基于归一化的差值分布采样下一个词元，从而有效地提升重要词元在生成过程中的影响力。

### 解码加速

### 低资源部署

## 提示学习

### In Context Learning

### Chain of Thought

## Agent

记忆（短、长期）、规划、执行

这一流程通常遵循以下步骤：首先，智能体对当前状态进行理解和分析。在这一过程中，它可能会从记忆组件中检索相关的历史信息或知识，以便更全面地理解和分析当前状态。接下来，规划组件通过综合考虑长短期记忆组件中已存储 的信息，生成下一个行动策略或计划。这一步骤涉及对多个执行方案进行预测与评估，以选择最优的行动路径。随后，执行组件负责根据规划组件生成的任务解决方案执行实际行动，并与当前环境产生交互。在执行过程中，智能体可能会借助外部工具或资源来增强自身的执行能力。最后，智能体通过感知单元或系统接口从环境中接收反馈信息，并将这些信息暂时存储于短期记忆中。智能体会对短期记忆中的新获取到的信息进行处理，例如舍弃掉和未来规划无关的观察。上述流程将作为新的记忆被记录在记忆组件中。

### 需考虑的问题

+ 智能体系统的计算资源消耗
+ 复杂工具使用（比如浏览器）
+ 高效的通信和交互
+ 面向智能体系统的基模适配
+ 面向真实世界的智能体模拟

## 评测

### 常见评测指标

#### 分类任务

以基础的二分类任务为例，真正例（True Positive, TP）表示预测类别为正的正样本、假正例（False Positive, FP）表示预测类别为正的负样本、真负例（True Negative, TN）表示预测类别为负的负样本、假负例（False Negative, FN）表示预测类别为负的正样本。如下表所示，这种组合划分可以由混淆矩阵（Confusion Matrix）来进行展示。在此基础上，分类任务通常采用精确率（Precision）、召回率（Recall）、F1 分数（F1 Score）等评测指标来评估模型的分类结果。

<table>
    <thead>
        <tr>
            <th rowspan="2">真实类别</th>
            <th colspan="2">预测类别</th>
        </tr>
        <tr>
            <th>正例</th>
            <th>负例</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>正例</td>
            <td>TP</td>
            <td>FN</td>
        </tr>
        <tr>
            <td>负例</td>
            <td>FP</td>
            <td>TN</td>
        </tr>
    </tbody>
</table>

+ **精确率**：表示模型预测为正例的样本中，确实为正例的比例：

$$
\text{Position}=\frac{\text{TP}}{\text{TP}+\text{FP}}
$$

+ **召回率**：所有真正为正例的样本中被模型正确预测出来的比例：

$$
\text{Recal}=\frac{\text{TP}}{\text{TP}+\text{FN}}
$$

+ **F1分数**：精确率和召回率的调和平均数，用于衡量模型在分类任务上的综合性能：

$$
\text{F1}=2*\frac{\text{Precision}*\text{Recal}}{\text{Precision}+\text{Recall}}
$$

#### 条件文本生成任务

#### 问答任务

#### 执行类任务

#### 偏好排序任务
