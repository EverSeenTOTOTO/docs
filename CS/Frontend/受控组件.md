# 受控组件与表单联动

一个小问题，一直没说出个所以然来，最近做了很多中后台表单相关的开发工作才有所思考，决定写个短篇笔记下。

## 受控组件

“受控组件”的概念似乎在 React 侧见到的比较多，说到底是一个数据同步的问题，通常我们表单项的值会来自于某些业务状态，并且表单项值改变时还要更新这些状态，全流程中表单项的行为都受我们控制。在Vue中等价的概念是“双向绑定”，参考下面两段代码：

```tsx
const App = () => {
  const [state, setState] = useState('hello world');

  return <input
    value={state}
    onChange={(e) => setState(e.target.value)}
  />;
};
```

```html
<script setup>
import { ref } from 'vue';

const state = ref('hello world');

const handleChange = (e) => {
  state.value = e.target.value;
};

</script>
<template>
  <div>
    <input
      :value="state"
      @change="handleChange"
    >
  </div>
</template>
```

组件受控的情况下，UI 展示是由业务状态所驱动的，数据的流向清晰，我们可以聚焦于业务状态管理而不必手动更新 UI。但也有些时候，我们会用到非受控的组件，典型例子是表单项初始值来自于某个业务状态，随后表单的更新则无需同步到该**外部**状态。这时表单项的值通常是自我管理的。

下面这段代码，我们站在`<App />`的角度，把`<FakeInput />`想象成 HTML 原生的`input`组件，则`<FakeInput />`的内部状态改变对`<App />`来说是无法感知的，要获取或调整`<FakeInput />`最新的值，通常会借助`ref`，这相当于回到了 jQuery 那种刀耕火种的年代，因此大多数时候我们都尽可能使用受控组件，避免使用`ref`。

```tsx
const FakeInput: React.FC<{ value: string }> = (props) => {
  const [state, setState] = useState(props.value);

  return <input
    value={state}
    onChange={(e) => setState(e.target.value)}
  />;
};

const App = () => <FakeInput value="hello world" />;
```

## 表单联动

表单联动即一个表单项的属性（值、选项、校验规则等）随着另一个表单项的属性变化而变化，在中后台业务开发中非常常见。下面我们把被依赖的组件和联动组件分别记作 Base 和 Derived，很自然地会写出这样的代码：

```tsx
const App = () => {
  const [baseValue, setBaseValue] = useState('');
  const [derivedValue, setDerivedValue] = useState('');

  useEffect(() => setDerivedValue(baseValue), [baseValue]);

  return <>
    <input value={baseValue} onChange={(e) => setBaseValue(e.target.value)} />
    <input value={derivedValue} onChange={(e) => setDerivedValue(e.target.value)} />
  </>;
};
```

```html
<script setup>
import { ref, watch } from 'vue';

const base = ref('');
const derived = ref('');

watch(base, (newValue) => {
  derived.value = newValue;
});

</script>
<template>
  <div>
    <input v-model="base">
    <input v-model="derived">
  </div>
</template>
```

上面的代码有两点值得一说，首先，它道出了我写这篇文档最初的念想：**当存在联动关系的两个组件都受控时，似乎只能通过手动赋值这么一种不太优雅的方式来更新 Derived 组件的值**，就像我们在`useEffect`和`watch`中所做的那样，大量这样的依赖逻辑累积起来会非常难以维护，Antd `Form`的`dependency`算是给出了一种权宜之计，但书写起来也很麻烦；其次，这两段代码都隐含着一条前提：**我们可以将不同表单项的状态提炼到上层存储统一管理，形成状态下发的单向数据流，即所谓的“状态提升”**。假如前提只能部分满足，比如依赖是单向的，我们不方便改动被依赖的 Base 代码，这时最好在依赖倒置原则的指引下，将联动逻辑书写在 Derived 组件内部，避免在 Base 状态更新回调中手动更新 Derived 组件，形成高度内聚的代码：

```tsx
const Derived: React.FC<{ name: string }> = (props) => {
  // 设法获取baseValue，还是离不开 Context 之类的上层状态存储
  const baseValue = getFieldValue('base');

  // 联动
  useEffect(() => setFieldValue('derived', baseValue), [baseValue]);

  return <input name={props.name} />;
};

const App = () => <>
  <input name="base" />
  <Derived name="derived" />
</>;
```
