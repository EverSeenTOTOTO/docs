# 停机问题[^l1]

[^l1]: 《计算理论导引（第三版）》\[美] Michael Sipser

## 可判定性

检测一个特定的确定型有穷自动机是否接受一个事先给定的串，此问题可以表示为语言$A_{DFA}$，它包含了所有DFA的编码以及DFA接受的串的编码：

$$
A_{DFA}=\{<B,w>|B是DFA且接受输入串w\}
$$

问题“$B$是否接受输入$w$”与问题“$<B,w>$是否是$A_{DFA}$的元素”是等价的。类似的，其他一些计算问题也可以表示成检查语言的成员隶属关系，证明这个语言是可判定的与证明这个计算问题是可判定的是一回事。

只要证明$A_{DFA}$是可判定的，也就证明了“一个给定的有穷自动机是否接受一个给定的串”是可判定的。我们对“可判定性”的定义是能找到一台图灵机H作为该问题的判定器，因此只要设计一个判定$A_{DFA}$的图灵机即可。就像我们使用通用编程语言编写一个图灵机的模拟那样，我们使用该图灵机模拟DFA并输入$w$，如果模拟以接受状态结束，则图灵机也接受；反之拒绝。

有了上述热身，我们来看下面这个语言：

$$
A_{TM}=\{<M,w>|M是一台图灵机，且接受w\}
$$

**$A_{TM}$是不可判定的**。证明此结论的经典方法是反证法。

假设$A_{TM}$是可判定的，那么存在一个判定器（图灵机）$H$，对于任意输入$<M, w>$：
- 如果$M$接受$w$，$H$接受$<M, w>$。
- 如果$M$不接受$w$，$H$拒绝$<M, w>$。

现在，我们构造一个新的图灵机$D$，它以$H$为子程序。$D$的输入是另一台图灵机$M$的编码$<M>$。$D$在内部调用$H$来判定当$M$以自身的编码$<M>$为输入时会发生什么。根据$H$的输出，$D$执行相反的操作：
1. $D$接收输入$<M>$。
2. $D$在内部运行$H$，输入为$<M, <M>>$。
3. 如果$H$接受，说明$M$会接受$<M>$，则$D$拒绝。
4. 如果$H$拒绝，说明$M$不会接受$<M>$，则$D$接受。

现在，考虑将$D$自身的编码$<D>$作为输入提供给$D$。根据$D$的定义，会发生以下情况：
- 如果$D$接受$<D>$，那么根据步骤4，$H$必须拒绝$<D, <D>>$。而$H$拒绝意味着$D$不接受$<D>$。这产生了矛盾。
- 如果$D$拒绝$<D>$，那么根据步骤3，$H$必须接受$<D, <D>>$。而$H$接受意味着$D$接受$<D>$。这也产生了矛盾。

无论哪种情况，我们都得出了一个逻辑上的矛盾。因此，最初的假设“$A_{TM}$是可判定的”必然是错误的。这个例子和上面正则语言可判定性例子的差别在于图灵机要比DFA更强大，证明$A_{TM}$可判定的图灵机自身也要被囊括在证明之内。

:::info
这也说明了图灵可识别性的范围要比可判定性要广。书里还有一段关于对角线方法的讲解也很精彩。利用对角线方法可以证明语言是不可数的，而图灵机却是可数的。由于一台图灵机只能识别一个语言，故存在图灵机不可识别的语言。
:::

## 停机问题

**归约**即将一个问题转化为另一个问题的过程。既然已经证明了$A_{TM}$是不可判定的，就可以将停机问题归约到这上面来。

$$
HALT_{TM}=\{<M,w>|M是一台图灵机，且对输入w停机\}
$$

假设$HALT_{TM}$是可判定的，即存在一台图灵机$R$可以判定$HALT_{TM}$。我们可以利用$R$来构造一台$A_{TM}$的判定器$S$。$S$的工作流程如下：
1. $S$接收输入$<M, w>$。
2. $S$在内部运行判定器$R$，输入为$<M, w>$。
3. 如果$R$拒绝（即$M$在输入$w$上不会停机），那么$M$必然不接受$w$。此时，$S$拒绝$<M, w>$。
4. 如果$R$接受（即$M$在输入$w$上会停机），$S$就继续在内部模拟$M$在输入$w$上的运行。因为已经知道$M$会停机，所以这个模拟过程必定会结束。
5. 模拟结束后，如果$M$进入接受状态，$S$就接受$<M, w>$；如果$M$进入拒绝状态，$S$就拒绝$<M, w>$。

这样一来，图灵机$S$就能够判定任意的$<M, w>$是否属于$A_{TM}$。这意味着$S$是$A_{TM}$的判定器。然而我们已经证明了$A_{TM}$是不可判定的，这与$S$的存在相矛盾。因此，最初的假设“$HALT_{TM}$是可判定的”是错误的。

:::info
其实这些证明的重点都在于处理无限循环。**判定器需要能终止**，但机器不能检测自身是否进入了无限循环，然而我们可以用一台图灵机来模拟（编码运行）其他状态规模更小的机器，当输入串结束时，通过查看被模拟的机器是否进入接受状态来决定自己是接受还是拒绝。这样我们只需要保证被模拟的机器能读完输入串，不会在中途进入无限循环，也就是“空转”却不读取输入的情况发生。对于正则文法，由于与NFA等价，而任意的NFA都可以转化成DFA，因此一定可以读到输入串的末尾处。对于PDA或图灵机，由于它们确实允许只进行栈操作（读写头操作）而不读取输入，所以没法保证。这也是上面正则文法的例子没有强调无限循环，而停机问题的例子中却没有直接让$S$模拟$M$，而是先通过模拟$R$来保证$S$停机的原因。本文没有摘录对CFG可判定性的证明，该证明如果直接用$S$模拟PDA也会遇到类似的问题，解决方案是利用任意CFG都可以转化为乔姆斯基范式，而乔姆斯基范式具有一个特殊性质：该CFG的任意派生串$w$都只需要$2n-1$步，$n$是$w$的长度。因此我们只需要列出CFG的所有$2n-1$步的派生，检查$w$是否在这些派生中即可。

也许有人会质疑这里”机器不能检测自身是否无限循环“的前提，实际当机器进入无限循环时，如果要检测这个情况我们需要添加上一些代码，一些不会因无限循环而无法执行的模块，从而改变了这台机器的范畴，现在要检测的机器已经不仅仅是原来的机器了，于是为了检测新的机器是否进入无限循环又需要添加新的代码，又扩大了机器的内涵……来自哥德尔的凝视……
:::

## 罗素悖论[^2]

[^2]: 《陶哲轩实分析（第3版）》\[澳] 陶哲轩

用状态规模来表述上面“无限循环”的动态过程，机器正不断地试图往自己的纸带（存储单元）中添加一个能够表示当下自己的编码，而一旦添加了这个编码，机器的范畴就发生了改变，需要扩充编码来容纳这个崭新的自己，这个过程是机器无限趋近自包含的过程。可以想见，最终纸带的长度将趋于无限。

集合论中存在一个危险的概括性公理，断言**每一个性质都对应一个集合**：对任意的对象$x$，若存在$x$的性质$P(x)$，那么存在一个集合$\{x|P(x)为真\}$。罗素悖论的思路在于找到这样一种性质，集合不包含自身：$x$是一个集合，且$x \notin x$。通过考察一个由所有不包含自身的集合构成的集合就可以得出矛盾（是否包含自身也是对象的一种属性，因此根据概括公理就能找到对应的一个集合）。

对于可判定性问题来说，“包含自身”对应的就是一台图灵机能模拟并判定自己。令性质$P(x)$表示“$x$是一台图灵机，且$x$不能够判定自己”，根据概括公理这些图灵机是存在的。于是我们就可以考察这样一台图灵机$\Omega$：$\Omega$能够判定所有不能判定自己的图灵机。下面的问题就是$P(\Omega)$是否为真，如果为真，说明$\Omega$不能够判定自己，因此根据$\Omega$的属性它应该能判定自己；如果为假，即$\Omega$能够判定自己，但$\Omega$自身的性质决定了它不能判定能判定自己的图灵机，从而矛盾。

这里概括公理的问题在于太过宽泛，从而允许了$\Omega$的存在。解决概括公理荒谬之处的一种“非正式”方法是：考虑将对象按照一定的层次结构进行排列。前文机器范畴的说法就体现了这样的思想，其中的关键在于无论在哪一个层级，我们都无法构造出包含自身的集合。存在一个**正则（基础）公理**，可以确保罗素悖论不会出现：对于任意非空集合$A$，$A$中至少存在一个元素$x$满足：要么$x$不是集合，要么与$A$不相交。这个性质保证了$A$中至少有一个元素位于对象层级比较低的位置，以至于该元素不包含$A$中的其他任何元素。根据这个公理可以推出结论$A
otin A$（否则${A}$就可以被构造出来。而且间接地循环自指也不被允许，例如我可能尝试构造$A={B},B={C}, C={A}$，$A, B, C$单拎出来都满足正则公理，但如果这三个集合能够同时存在，就可以构造出非空集合$T={A, B, C}$不满足正则公理）。

:::info
分类公理：设$A$是一个集合，对$forall x\in A$，$P(x)$是$x$的一个性质，则集合$\{x|P(x)为真\}$存在。如果我们对比分类公理和概括公理，发现前者仅仅比后者多了一条$x$属于某集合$A$的前提条件，这间接说明概括公理等价于承认了一个大而全的集合$U$的存在，所有的对象（也包括$U$！！！）都属于这个集合。因此正则公理与概括公理是互斥的。
:::

用图灵机判定问题类比，“$A$非空”对应于$A$可以模拟并判定一些图灵机，“$x$不是集合”意味着$x$可能是一些能力较小的机器（如DFA），“$x$与$A$不相交”则可以直观地类比为$x$与$A$判定的图灵机没有交集。整理一下就是：“对于任意图灵机$A$，$A$可以模拟并判定的机器中至少存在一台机器$x$满足：要么$x$不是图灵机，要么$x$是图灵机，但它判定的图灵机与$A$判定的图灵机没有交集。”这个类比出来的“公理”保证了$A$所判定的机器层级总是低于自己（若$A$判定$B$、$B$判定$C$而$C$判定$A$，则$A$也可以判定$A$）。

这个类比看起来似乎承认了图灵机判定器的存在，与前文的结论矛盾，但其实不然。当我们讨论$A_{TM}$的不可判定性时，我们实际上是在讨论一台能够判定**所有**图灵机的“通用图灵机”$U$。正是这种无限制的“通用性”导致了自指悖论的出现，无论是前文构造的$H$、$D$还是$\Omega$，身上都有这种通用性的影子。$A_{TM}$的不可判定性，本质上是说一台拥有无限状态（无限长纸带）的通用图灵机是无法构造出来的。

然而，如果我们对图灵机的能力加以限制，例如限制其纸带长度，就得到了“线性有界自动机（LBA）”。对于LBA，停机问题是可判定的。这对应了现实世界中我们拥有诸多代码静态分析、模型检测等软件分析工具的原因——它们分析的对象是状态有限的程序，而非理论上无限的通用图灵机。
